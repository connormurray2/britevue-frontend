"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var abs = require("./cssProcesor");
var Set = (function () {
    function Set(keys) {
        this.entries = keys || [];
    }
    Set.prototype.add = function (obj) {
        this.entries.push(obj);
        return this;
    };
    Set.prototype.has = function (obj) {
        return this.entries.indexOf(obj) !== -1;
    };
    Set.prototype.delete = function (obj) {
        var index = this.entries.indexOf(obj);
        if (~index) {
            this.entries.splice(index, 1);
        }
    };
    Object.defineProperty(Set.prototype, "size", {
        get: function () {
            return this.entries.length;
        },
        enumerable: true,
        configurable: true
    });
    Set.prototype.toString = function () {
        return this.entries;
    };
    return Set;
}());
function parentMethods(target, instance) {
    if (Array.prototype['findIndex']) {
        Object.getOwnPropertyNames(target.prototype).forEach(function (prop) {
            instance[prop] = target.prototype[prop];
        });
    }
}
exports.parentMethods = parentMethods;
function getAllProperties(obj) {
    var curr = obj;
    var allProps = [];
    do {
        var name_1 = curr.constructor.name;
        if (name_1 !== 'Object' && name_1 !== 'Vue') {
            var props = Object.getOwnPropertyNames(curr);
            props.forEach(function (prop) {
                if (!~allProps.indexOf(prop) && prop !== 'constructor')
                    allProps.push(prop);
            });
        }
        else
            break;
    } while (curr = Object.getPrototypeOf(curr));
    return allProps;
}
exports.getAllProperties = getAllProperties;
function getDeepValue(object, propertys) {
    var keys = [];
    if (typeof propertys === 'string') {
        keys = propertys.split('.');
    }
    else {
        throw new Error('Parameter propertys must be a string.');
    }
    return keys.reduce(function (o, p) { return (o || {})[p]; }, object);
    ;
}
exports.getDeepValue = getDeepValue;
function insertCss(id, css) {
    var isNew = false;
    var sty = document.head.querySelector('#' + id);
    if (!sty) {
        isNew = true;
        sty = document.createElement('style');
        sty.id = id;
        sty.setAttribute('refs', '1');
    }
    if (sty.textContent !== css) {
        sty.textContent = css;
    }
    if (isNew) {
        document.head.appendChild(sty);
    }
    else {
        var count = parseInt(sty.getAttribute('refs'), 10);
        count++;
        sty.setAttribute('refs', count.toString());
    }
}
exports.insertCss = insertCss;
function deleteCss(id) {
    var sty = document.head.querySelector('#' + id);
    if (sty) {
        var count = parseInt(sty.getAttribute('refs'), 10);
        count--;
        if (count === 0) {
            document.head.removeChild(sty);
        }
        else {
            sty.setAttribute('refs', count.toString());
        }
    }
}
exports.deleteCss = deleteCss;
function assign(target) {
    var sources = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        sources[_i - 1] = arguments[_i];
    }
    if (target === undefined || target === null) {
        throw new TypeError('Cannot convert undefined or null to object');
    }
    var output = Object(target);
    for (var i = 0; i < sources.length; i++) {
        var source = sources[i];
        if (source !== undefined && source !== null) {
            for (var nextKey in source) {
                if (source.hasOwnProperty(nextKey) && !isCircular(source[nextKey])) {
                    output[nextKey] = source[nextKey];
                    if (Array.isArray(source[nextKey])) {
                        output[nextKey] = source[nextKey].slice();
                    }
                    else if (Object.prototype.toString.call(source[nextKey]) === '[object Date]') {
                        output[nextKey] = new Date(source[nextKey].valueOf());
                    }
                    else if (typeof source[nextKey] === 'object') {
                        output[nextKey] = assign({}, source[nextKey]);
                    }
                }
                else {
                    output[nextKey] = output;
                }
            }
        }
    }
    return output;
}
exports.assign = assign;
function isCircular(obj) {
    var detected = false;
    var stackSet = new Set();
    function detect(obj) {
        if (typeof obj !== 'object' || stackSet.has(obj)) {
            detected = typeof obj === 'object';
            return;
        }
        stackSet.add(obj);
        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                detect(obj[key]);
            }
        }
        stackSet.delete(obj);
        return;
    }
    detect(obj);
    return detected;
}
function pad(hash, len) {
    while (hash.length < len) {
        hash = "0" + hash;
    }
    return hash;
}
function fold(hash, text) {
    var i, chr, len;
    if (text.length === 0) {
        return hash;
    }
    for (i = 0, len = text.length; i < len; i++) {
        chr = text.charCodeAt(i);
        hash = ((hash << 5) - hash) + chr;
        hash |= 0;
    }
    return hash < 0 ? hash * -2 : hash;
}
function hash(value) {
    var preHash = fold(0, value);
    if (value === null) {
        preHash = fold(preHash, 'null');
    }
    else if (value === undefined) {
        preHash = fold(preHash, 'undefined');
    }
    else {
        preHash = fold(preHash, value.toString());
    }
    return pad(preHash.toString(16), 8);
}
exports.hash = hash;
function scopedCss(style, hash) {
    var css = abs({ minify: true });
    var rules = style['rules'] ? style['rules'] : style;
    if (style['props']) {
        var props = style['props'];
        for (var prop in props) {
            if (props.hasOwnProperty(prop)) {
                css.prop(prop, props[prop]);
            }
        }
    }
    return css(rules, hash);
}
exports.scopedCss = scopedCss;
//# sourceMappingURL=tools.js.map