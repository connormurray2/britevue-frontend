"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var tools_1 = require("./tools");
var utilities_1 = require("./utilities");
var newline = '\n';
var defaultOptions = {
    minify: false,
    keepCamelCase: false,
    combineSelectors: true
};
function toCSS(rules, options, indent) {
    var css = '';
    indent = indent || options['indent'] || ['', '  '];
    for (var selector in rules) {
        if (~selector.indexOf("____raw")) {
            var rawSel = /(____raw_)/.exec(selector)[0];
            css += rules[selector][rawSel] + newline;
        }
        else {
            var entityStyle = "" + indent[0] + selector + " {" + newline;
            var entity = '';
            for (var prop in rules[selector]) {
                var value = rules[selector][prop];
                if (value === '') {
                    value = '""';
                }
                prop = prop.replace(/[$]\d*/, '');
                prop = options && options.keepCamelCase === true ? prop : utilities_1.camelToKebabCase(prop);
                entity += "" + indent[1] + prop + ": " + value + ";" + newline;
            }
            if (entity !== '') {
                entityStyle += entity;
                entityStyle += indent[0] + "}" + newline;
                css += entityStyle;
            }
        }
    }
    return css;
}
function combineSelectors(rules, preventCombining, keepCamelCase) {
    var map = [], arr = {};
    preventCombining = [].concat(preventCombining || []);
    preventCombining.splice(0, 0, '');
    var prevent = preventCombining.join('|');
    for (var selector in rules) {
        var props = rules[selector];
        for (var prop in props) {
            map.push({
                selector: selector,
                prop: prop,
                value: props[prop],
                combine: prevent.indexOf('|' + prop) < 0 && selector.indexOf('@font-face') < 0
            });
        }
    }
    for (var i = 0; i < map.length; i++) {
        if (map[i].combine === true && map[i].selector !== false) {
            for (var j = i + 1; j < map.length; j++) {
                var propi = keepCamelCase ? map[i].prop : utilities_1.camelToKebabCase(map[i].prop);
                var propj = keepCamelCase ? map[j].prop : utilities_1.camelToKebabCase(map[j].prop);
                if (propi === propj && map[i].value === map[j].value) {
                    map[i].selector += ', ' + map[j].selector.replace(/[$]\d*/, '');
                    map[j].selector = false;
                }
            }
        }
    }
    for (var i = 0; i < map.length; i++) {
        if (map[i].selector !== false) {
            if (!arr[map[i].selector]) {
                arr[map[i].selector] = {};
            }
            arr[map[i].selector][map[i].prop] = map[i].value;
        }
    }
    return arr;
}
function minify(content) {
    return content
        .replace(/\/\*(?:(?!\*\/)[\s\S])*\*\/|[\r\n\t]+/g, '')
        .replace(/ {2,}/g, ' ')
        .replace(/ ([{:}]) /g, '$1')
        .replace(/: /g, ':')
        .replace(/([;,]) /g, '$1')
        .replace(/ !/g, '!');
}
function processor(rules, options) {
    options = options || defaultOptions;
    var css = '';
    for (var stylesheet in rules) {
        var r = rules[stylesheet];
        r = options.combineSelectors ? combineSelectors(r, options.preventCombining, options.keepCamelCase) : r;
        if (stylesheet === 'mainstream') {
            css += toCSS(r, options);
        }
        else {
            css += stylesheet + " {" + newline + toCSS(r, options, ['  ', '    ']) + "}" + newline;
        }
    }
    if (options.minify) {
        css = minify(css);
    }
    return css;
}
function abstractStyle(options) {
    var localPlugins = {};
    var HASHCLASS = '____HASHCLASS____';
    localPlugins['keyframes'] = keyframes;
    var abtStyle = function (objRules, hashClass) {
        var scopeClass = hashClass ? "scope_" + hashClass : HASHCLASS;
        var ruleResgitered = [];
        var allRules = { mainstream: {} };
        options = __assign({ combineSelectors: true, preventCombining: ['@font-face'] }, (options || {}));
        function execPlugins(selector, property, value, stylesheet, parentSelector) {
            var _a = nonPrefixProp(property), prop = _a.prop, prefix = _a.prefix;
            var plugin = localPlugins[prop];
            if (typeof plugin !== 'undefined') {
                var pluginResponse = plugin(value, prefix);
                if (pluginResponse) {
                    addRule(selector, pluginResponse, stylesheet, parentSelector);
                }
                return true;
            }
            else {
                return false;
            }
        }
        function addRule(selector, props, stylesheet, parentSelector) {
            stylesheet = stylesheet || 'mainstream';
            if (props === null || typeof props === 'undefined' || props === false) {
                return;
            }
            if (!parentSelector && !selector) {
                selector = '';
            }
            if (typeof props.classify !== 'undefined' && props.classify === true) {
                props = typeof props.toJSON !== 'undefined' ? props.toJSON() : props.toString();
            }
            if (/, ?/g.test(selector) && options.combineSelectors) {
                var parts = selector.replace(/, /g, ',').split(',');
                for (var i = 0; i < parts.length; i++) {
                    var p = parts[i];
                    addRule(p, props, stylesheet, parentSelector);
                }
                return;
            }
            if (execPlugins(null, selector, props, stylesheet, parentSelector)) {
                return;
            }
            if (typeof props.length !== 'undefined' && typeof props === 'object') {
                for (var i = 0; i < props.length; i++) {
                    var prop = props[i];
                    if (prop) {
                        addRule(selector, prop, stylesheet, parentSelector);
                    }
                }
                return;
            }
            var _props = {}, _selector = selector, _objects = {}, _functions = {};
            for (var prop in props) {
                var value = props[prop];
                if (value && typeof value.classify !== 'undefined' && value.classify === true) {
                    value = typeof value.toJSON !== 'undefined' ? value.toJSON() : value.toString();
                }
                var type = typeof value;
                if (type !== 'object' && type !== 'function' && value !== false && value !== true) {
                    if (execPlugins(selector, prop, value, stylesheet, parentSelector) === false) {
                        if (_selector.indexOf('^') === 0) {
                            _selector = _selector.substr(1, _selector.length - 1) + (typeof parentSelector !== 'undefined' ? ' ' + parentSelector : '');
                        }
                        else {
                            _selector = typeof parentSelector !== 'undefined' ? parentSelector + ' ' + selector : selector;
                        }
                        _props[prop] = value;
                        addPrefixes(prop, _props);
                    }
                }
                else if (type === 'object') {
                    _objects[prop] = value;
                }
                else if (type === 'function') {
                    _functions[prop] = value;
                }
            }
            ruleResgitered.push({
                selector: _selector,
                props: _props,
                stylesheet: stylesheet
            });
            for (var prop in _objects) {
                if (prop.charAt(0) === ':') {
                    addRule(selector + prop, _objects[prop], stylesheet, parentSelector);
                }
                else if (/&/g.test(prop)) {
                    if (/, ?/g.test(prop) && options.combineSelectors) {
                        var parts = prop.replace(/, /g, ',').split(',');
                        for (var i = 0; i < parts.length; i++) {
                            var part = parts[i];
                            if (part.indexOf('&') >= 0) {
                                addRule(part.replace(/&/g, selector), _objects[prop], stylesheet, parentSelector);
                            }
                            else {
                                addRule(part, _objects[prop], stylesheet, typeof parentSelector !== 'undefined' ? parentSelector + ' ' + selector : selector);
                            }
                        }
                    }
                    else {
                        addRule(prop.replace(/&/g, selector), _objects[prop], stylesheet, parentSelector);
                    }
                }
                else if (prop.indexOf('@media') === 0 || prop.indexOf('@supports') === 0) {
                    addRule(selector, _objects[prop], prop, parentSelector);
                }
                else if (selector.indexOf('@media') === 0 || prop.indexOf('@supports') === 0) {
                    addRule(prop, _objects[prop], selector, parentSelector);
                }
                else if (selector.indexOf('^') === 0) {
                    var sel = selector.substr(1, selector.length - 1) + (typeof parentSelector !== 'undefined' ? ' ' + parentSelector : '') + ' ' + prop;
                    addRule(sel, _objects[prop], stylesheet);
                }
                else if (execPlugins(selector, prop, _objects[prop], stylesheet, parentSelector) === false) {
                    addRule(prop, _objects[prop], stylesheet, (parentSelector ? parentSelector + ' ' : '') + selector);
                }
            }
            for (var prop in _functions) {
                var obj = {};
                obj[prop] = _functions[prop]();
                addRule(selector, obj, stylesheet, parentSelector);
            }
        }
        try {
            var stylesheet = 'mainstream';
            for (var selector in objRules) {
                addRule(selector, objRules[selector], stylesheet);
            }
            for (var i = 0; i < ruleResgitered.length; i++) {
                stylesheet = ruleResgitered[i].stylesheet;
                var props = ruleResgitered[i].props;
                var selector = addScope(ruleResgitered[i].selector, "." + (scopeClass || HASHCLASS));
                allRules[stylesheet] = allRules[stylesheet] || {};
                var rules = allRules[stylesheet];
                var current = rules[selector] || {};
                for (var prop in props) {
                    var value = props[prop];
                    if (typeof value !== 'object') {
                        if (value.toString().charAt(0) === '+') {
                            if (current && current[prop]) {
                                current[prop] = current[prop] + ', ' + value.substr(1, value.length - 1);
                            }
                            else {
                                current[prop] = value.substr(1, value.length - 1);
                            }
                        }
                        else if (value.toString().charAt(0) === '>') {
                            if (current && current[prop]) {
                                current[prop] = current[prop] + ' ' + value.substr(1, value.length - 1);
                            }
                            else {
                                current[prop] = value.substr(1, value.length - 1);
                            }
                        }
                        else {
                            current[prop] = value;
                        }
                    }
                }
                rules[selector] = current;
            }
        }
        catch (err) {
            throw new Error('Error adding: ' + JSON.stringify({ rules: objRules, error: err.toString() }));
        }
        var className = '';
        var styleText = processor(allRules, options);
        if (scopeClass) {
            className = scopeClass;
        }
        else {
            var toHash = minify(styleText.replace(new RegExp("\\." + HASHCLASS, 'g'), ''));
            className = "scope_" + tools_1.hash(toHash);
            styleText = styleText.replace(new RegExp(HASHCLASS, 'g'), className);
        }
        return { className: className, styleText: styleText };
    };
    abtStyle.prop = function (pluginName, pluginAction) {
        localPlugins[pluginName] = pluginAction;
        return abtStyle;
    };
    abtStyle.process = function (rules, options) {
        return processor({ mainstream: rules }, options);
    };
    abtStyle.raw = function (rules, options) {
        return rawContent(processor({ mainstream: rules }, options));
    };
    return abtStyle;
}
;
function rawContent(raw) {
    var id = '____raw_', object = (_a = {}, _a[id] = (_b = {}, _b[id] = raw, _b), _a);
    return object;
    var _a, _b;
}
function keyframes(value) {
    if (typeof value === 'object') {
        var frames_1;
        if (typeof value['frames'] !== 'undefined') {
            frames_1 = value['frames'];
        }
        var key = "@keyframes " + value['name'];
        var wkey = "@-webkit-keyframes " + value['name'];
        var frm = processor({ mainstream: frames_1 }, { combineSelectors: false, indent: ['  ', '    '] });
        return rawContent(key + " {\n" + frm + "}\n" + wkey + " {\n" + frm + "}");
    }
}
function removeExtraSpaces(sel) {
    return sel.trim()
        .replace(/\s*(,)\s*/g, '$1')
        .replace(/\s*(>)\s*/g, '$1')
        .replace(/\s*(\+)\s*/g, '$1')
        .replace(/\s*(~)\s*/g, '$1');
}
function include(sel) {
    return !!(~sel.indexOf(' ') || ~sel.indexOf(',') || ~sel.indexOf('>') || ~sel.indexOf('+') || ~sel.indexOf('~'));
}
function addScope(sel, scope) {
    sel = removeExtraSpaces(sel);
    var prefix = sel.charAt(0);
    if (include(sel)) {
        if (~sel.indexOf(' ')) {
            sel = addScopeToList(sel, scope, ' ');
        }
        else if (~sel.indexOf(',')) {
            sel = addScopeToList(sel, scope, ', ');
        }
        else if (~sel.indexOf('>')) {
            sel = addScopeToList(sel, scope, ' > ');
        }
        else if (~sel.indexOf('+')) {
            sel = addScopeToList(sel, scope, ' + ');
        }
        else if (~sel.indexOf('~')) {
            sel = addScopeToList(sel, scope, ' ~ ');
        }
    }
    else if (prefix === '.' || prefix === '#' || prefix === '[') {
        sel = scope + sel;
    }
    else if (~sel.indexOf(':')) {
        var parts = sel.split(':');
        sel = parts[0] + scope + ':' + parts.slice(1).join(':');
    }
    else if (prefix !== '@') {
        var parts = sel.split(' ');
        sel = parts[0] + scope + ' ' + parts.slice(1).join(' ');
    }
    return sel.trim();
}
function addScopeToList(sel, scope, sep) {
    if (!~sel.indexOf('@')) {
        sel = sel.split(sep !== ' ' ? sep.trim() : sep)
            .map(function (select) { return addScope(select, scope); }).join(sep);
    }
    return sel;
}
function prefixExtract(prop) {
    var result = {};
    var match = prop.match(/^\-(w|m|s|o)+\-/);
    if ((match || prop.charAt(0) === '-') && !prop.match(/^\-(webkit|moz|ms)+\-/)) {
        if (match !== null && match[0]) {
            result = { prefix: match[0].replace(/-/g, '') };
            result.prop = prop.replace(match[0], '');
        }
        else {
            result = { prefix: '' };
            result.prop = prop.substr(1, prop.length);
        }
    }
    else {
        result = {
            prefix: false,
            prop: prop
        };
    }
    return result;
}
function addPrefixes(prop, obj) {
    var originalProp = prop, p = prefixExtract(prop), value = obj[prop];
    if (p.prefix !== false) {
        delete obj[originalProp];
        obj[p.prop] = value;
        var isEmpty = p.prefix === '';
        if (isEmpty || ~p.prefix.indexOf('w')) {
            obj["-webkit-" + p.prop] = value;
        }
        if (isEmpty || ~p.prefix.indexOf('m')) {
            obj["-moz-" + p.prop] = value;
        }
        if (isEmpty || ~p.prefix.indexOf('s')) {
            obj["-ms-" + p.prop] = value;
        }
        if (isEmpty || ~p.prefix.indexOf('o')) {
            obj["-o-" + p.prop] = value;
        }
    }
}
function nonPrefixProp(prop) {
    var p = prefixExtract(prop);
    if (p.prefix !== false) {
        if (p.prefix === '') {
            p.prefix = '-';
        }
        else {
            p.prefix = "-" + p.prefix + "-";
        }
    }
    return p;
}
module.exports = abstractStyle;
//# sourceMappingURL=cssProcesor.js.map