import * as tslib_1 from "tslib";
import { ObjectMaker } from "../util/object-maker";
import { AnnotationTypes } from "../core/validator.static";
import { ValidatorValueChecker } from "../util/validator-value-checker";
import { getConfigObject } from "../util/config-provider";
import { APP_VALIDATORS } from "../const/app-validators.const";
export function orValidator(configModel) {
    return function (control) {
        var e_1, _a;
        var config = getConfigObject(configModel, control);
        if (ValidatorValueChecker.pass(control, config)) {
            var validatorNames = Object.keys(config.validation);
            var failed = false;
            try {
                for (var validatorNames_1 = tslib_1.__values(validatorNames), validatorNames_1_1 = validatorNames_1.next(); !validatorNames_1_1.done; validatorNames_1_1 = validatorNames_1.next()) {
                    var validatorName = validatorNames_1_1.value;
                    failed = typeof config.validation[validatorName] == "boolean" ? APP_VALIDATORS[validatorName]()(control) : APP_VALIDATORS[validatorName](config.validation[validatorName])(control);
                    if (!failed)
                        break;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (validatorNames_1_1 && !validatorNames_1_1.done && (_a = validatorNames_1.return)) _a.call(validatorNames_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            if (failed)
                return ObjectMaker.toJson(AnnotationTypes.or, config, [control.value]);
        }
        return ObjectMaker.null();
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3IudmFsaWRhdG9yLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHJ4d2ViL3JlYWN0aXZlLWZvcm1zLyIsInNvdXJjZXMiOlsicmVhY3RpdmUtZm9ybS12YWxpZGF0b3JzL29yLnZhbGlkYXRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBR0EsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBRW5ELE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUMzRCxPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSxpQ0FBaUMsQ0FBQztBQUN4RSxPQUFPLEVBQUMsZUFBZSxFQUFDLE1BQU0seUJBQXlCLENBQUM7QUFDeEQsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLCtCQUErQixDQUFBO0FBQzlELE1BQU0sVUFBVSxXQUFXLENBQUMsV0FBa0M7SUFDMUQsT0FBTyxVQUFDLE9BQXdCOztRQUNoQyxJQUFJLE1BQU0sR0FBRyxlQUFlLENBQUMsV0FBVyxFQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ2xELElBQUkscUJBQXFCLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxNQUFNLENBQUMsRUFBRTtZQUMvQyxJQUFJLGNBQWMsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQztZQUNwRCxJQUFJLE1BQU0sR0FBVyxLQUFLLENBQUM7O2dCQUMzQixLQUF5QixJQUFBLG1CQUFBLGlCQUFBLGNBQWMsQ0FBQSw4Q0FBQSwwRUFBQztvQkFBcEMsSUFBSSxhQUFhLDJCQUFBO29CQUNuQixNQUFNLEdBQUcsT0FBTyxNQUFNLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQyxJQUFJLFNBQVMsQ0FBQyxDQUFDLENBQUUsY0FBYyxDQUFDLGFBQWEsQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFFLGNBQWMsQ0FBQyxhQUFhLENBQUMsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUM7b0JBQ3RMLElBQUcsQ0FBQyxNQUFNO3dCQUNSLE1BQU07aUJBQ1Q7Ozs7Ozs7OztZQUNELElBQUksTUFBTTtnQkFDUixPQUFPLFdBQVcsQ0FBQyxNQUFNLENBQUMsZUFBZSxDQUFDLEVBQUUsRUFBRSxNQUFNLEVBQUUsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztTQUMxRTtRQUNELE9BQU8sV0FBVyxDQUFDLElBQUksRUFBRSxDQUFDO0lBQzVCLENBQUMsQ0FBQTtBQUNILENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBYnN0cmFjdENvbnRyb2wgfSBmcm9tIFwiLi4vYWJzdHJhY3QvYWJzdHJhY3QtY29udHJvbFwiXHJcbmltcG9ydCB7IFZhbGlkYXRvckZuIH0gZnJvbSAnLi4vbW9kZWxzL2ludGVyZmFjZS92YWxpZGF0b3ItZm4nXHJcblxyXG5pbXBvcnQgeyBPYmplY3RNYWtlciB9IGZyb20gXCIuLi91dGlsL29iamVjdC1tYWtlclwiO1xyXG5pbXBvcnQgeyBMb2dpY2FsT3BlcmF0b3JDb25maWcgfSBmcm9tIFwiLi4vbW9kZWxzL2NvbmZpZy9sb2dpY2FsLW9wZXJhdG9yLWNvbmZpZ1wiO1xyXG5pbXBvcnQgeyBBbm5vdGF0aW9uVHlwZXMgfSBmcm9tIFwiLi4vY29yZS92YWxpZGF0b3Iuc3RhdGljXCI7XHJcbmltcG9ydCB7IFZhbGlkYXRvclZhbHVlQ2hlY2tlciB9IGZyb20gXCIuLi91dGlsL3ZhbGlkYXRvci12YWx1ZS1jaGVja2VyXCI7XHJcbmltcG9ydCB7Z2V0Q29uZmlnT2JqZWN0fSBmcm9tIFwiLi4vdXRpbC9jb25maWctcHJvdmlkZXJcIjtcclxuaW1wb3J0IHsgQVBQX1ZBTElEQVRPUlMgfSBmcm9tIFwiLi4vY29uc3QvYXBwLXZhbGlkYXRvcnMuY29uc3RcIlxyXG5leHBvcnQgZnVuY3Rpb24gb3JWYWxpZGF0b3IoY29uZmlnTW9kZWw6IExvZ2ljYWxPcGVyYXRvckNvbmZpZyk6IFZhbGlkYXRvckZuIHtcclxuICAgIHJldHVybiAoY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogeyBba2V5OiBzdHJpbmddOiBhbnkgfSB8IG51bGwgPT4ge1xyXG4gICAgbGV0IGNvbmZpZyA9IGdldENvbmZpZ09iamVjdChjb25maWdNb2RlbCxjb250cm9sKTtcclxuICAgIGlmIChWYWxpZGF0b3JWYWx1ZUNoZWNrZXIucGFzcyhjb250cm9sLCBjb25maWcpKSB7XHJcbiAgICAgIGxldCB2YWxpZGF0b3JOYW1lcyA9IE9iamVjdC5rZXlzKGNvbmZpZy52YWxpZGF0aW9uKTtcclxuICAgICAgbGV0IGZhaWxlZDpib29sZWFuID0gZmFsc2U7XHJcbiAgICAgIGZvcih2YXIgdmFsaWRhdG9yTmFtZSBvZiB2YWxpZGF0b3JOYW1lcyl7XHJcbiAgICAgICAgZmFpbGVkID0gdHlwZW9mIGNvbmZpZy52YWxpZGF0aW9uW3ZhbGlkYXRvck5hbWVdID09IFwiYm9vbGVhblwiID8gIEFQUF9WQUxJREFUT1JTW3ZhbGlkYXRvck5hbWVdKCkoY29udHJvbCkgOiAgQVBQX1ZBTElEQVRPUlNbdmFsaWRhdG9yTmFtZV0oY29uZmlnLnZhbGlkYXRpb25bdmFsaWRhdG9yTmFtZV0pKGNvbnRyb2wpO1xyXG4gICAgICAgIGlmKCFmYWlsZWQpXHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBpZiAoZmFpbGVkKVxyXG4gICAgICAgIHJldHVybiBPYmplY3RNYWtlci50b0pzb24oQW5ub3RhdGlvblR5cGVzLm9yLCBjb25maWcsIFtjb250cm9sLnZhbHVlXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gT2JqZWN0TWFrZXIubnVsbCgpO1xyXG4gIH1cclxufVxyXG4iXX0=