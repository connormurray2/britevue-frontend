import * as tslib_1 from "tslib";
import { ObjectMaker } from "../util/object-maker";
import { AnnotationTypes } from "../core/validator.static";
import { ValidatorValueChecker } from "../util/validator-value-checker";
import { getConfigObject } from "../util/config-provider";
import { APP_VALIDATORS } from "../const/app-validators.const";
export function notValidator(configModel) {
    return function (control) {
        var e_1, _a;
        var config = getConfigObject(configModel, control);
        if (ValidatorValueChecker.pass(control, config)) {
            var validatorNames = Object.keys(config.validation);
            var failed = false;
            try {
                for (var validatorNames_1 = tslib_1.__values(validatorNames), validatorNames_1_1 = validatorNames_1.next(); !validatorNames_1_1.done; validatorNames_1_1 = validatorNames_1.next()) {
                    var validatorName = validatorNames_1_1.value;
                    failed = typeof config.validation[validatorName] == "boolean" ? APP_VALIDATORS[validatorName]()(control) : APP_VALIDATORS[validatorName](config.validation[validatorName])(control);
                    if (!failed)
                        break;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (validatorNames_1_1 && !validatorNames_1_1.done && (_a = validatorNames_1.return)) _a.call(validatorNames_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            if (!failed)
                return ObjectMaker.toJson(AnnotationTypes.not, config, [control.value]);
        }
        return ObjectMaker.null();
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm90LnZhbGlkYXRvci5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0ByeHdlYi9yZWFjdGl2ZS1mb3Jtcy8iLCJzb3VyY2VzIjpbInJlYWN0aXZlLWZvcm0tdmFsaWRhdG9ycy9ub3QudmFsaWRhdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFHQSxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFFbkQsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQzNELE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLGlDQUFpQyxDQUFDO0FBQ3hFLE9BQU8sRUFBQyxlQUFlLEVBQUMsTUFBTSx5QkFBeUIsQ0FBQztBQUN4RCxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sK0JBQStCLENBQUE7QUFDOUQsTUFBTSxVQUFVLFlBQVksQ0FBQyxXQUFrQztJQUMzRCxPQUFPLFVBQUMsT0FBd0I7O1FBQ2hDLElBQUksTUFBTSxHQUFHLGVBQWUsQ0FBQyxXQUFXLEVBQUMsT0FBTyxDQUFDLENBQUM7UUFDbEQsSUFBSSxxQkFBcUIsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLE1BQU0sQ0FBQyxFQUFFO1lBQy9DLElBQUksY0FBYyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQ3BELElBQUksTUFBTSxHQUFXLEtBQUssQ0FBQzs7Z0JBQzNCLEtBQXlCLElBQUEsbUJBQUEsaUJBQUEsY0FBYyxDQUFBLDhDQUFBLDBFQUFDO29CQUFwQyxJQUFJLGFBQWEsMkJBQUE7b0JBQ25CLE1BQU0sR0FBRyxPQUFPLE1BQU0sQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDLElBQUksU0FBUyxDQUFDLENBQUMsQ0FBRSxjQUFjLENBQUMsYUFBYSxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUUsY0FBYyxDQUFDLGFBQWEsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQztvQkFDdEwsSUFBRyxDQUFDLE1BQU07d0JBQ1IsTUFBTTtpQkFDVDs7Ozs7Ozs7O1lBQ0QsSUFBSSxDQUFDLE1BQU07Z0JBQ1QsT0FBTyxXQUFXLENBQUMsTUFBTSxDQUFDLGVBQWUsQ0FBQyxHQUFHLEVBQUUsTUFBTSxFQUFFLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7U0FDM0U7UUFDRCxPQUFPLFdBQVcsQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUM1QixDQUFDLENBQUE7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQWJzdHJhY3RDb250cm9sIH0gZnJvbSBcIi4uL2Fic3RyYWN0L2Fic3RyYWN0LWNvbnRyb2xcIlxyXG5pbXBvcnQgeyBWYWxpZGF0b3JGbiB9IGZyb20gJy4uL21vZGVscy9pbnRlcmZhY2UvdmFsaWRhdG9yLWZuJ1xyXG5cclxuaW1wb3J0IHsgT2JqZWN0TWFrZXIgfSBmcm9tIFwiLi4vdXRpbC9vYmplY3QtbWFrZXJcIjtcclxuaW1wb3J0IHsgTG9naWNhbE9wZXJhdG9yQ29uZmlnIH0gZnJvbSBcIi4uL21vZGVscy9jb25maWcvbG9naWNhbC1vcGVyYXRvci1jb25maWdcIjtcclxuaW1wb3J0IHsgQW5ub3RhdGlvblR5cGVzIH0gZnJvbSBcIi4uL2NvcmUvdmFsaWRhdG9yLnN0YXRpY1wiO1xyXG5pbXBvcnQgeyBWYWxpZGF0b3JWYWx1ZUNoZWNrZXIgfSBmcm9tIFwiLi4vdXRpbC92YWxpZGF0b3ItdmFsdWUtY2hlY2tlclwiO1xyXG5pbXBvcnQge2dldENvbmZpZ09iamVjdH0gZnJvbSBcIi4uL3V0aWwvY29uZmlnLXByb3ZpZGVyXCI7XHJcbmltcG9ydCB7IEFQUF9WQUxJREFUT1JTIH0gZnJvbSBcIi4uL2NvbnN0L2FwcC12YWxpZGF0b3JzLmNvbnN0XCJcclxuZXhwb3J0IGZ1bmN0aW9uIG5vdFZhbGlkYXRvcihjb25maWdNb2RlbDogTG9naWNhbE9wZXJhdG9yQ29uZmlnKTogVmFsaWRhdG9yRm4ge1xyXG4gICAgcmV0dXJuIChjb250cm9sOiBBYnN0cmFjdENvbnRyb2wpOiB7IFtrZXk6IHN0cmluZ106IGFueSB9IHwgbnVsbCA9PiB7XHJcbiAgICBsZXQgY29uZmlnID0gZ2V0Q29uZmlnT2JqZWN0KGNvbmZpZ01vZGVsLGNvbnRyb2wpO1xyXG4gICAgaWYgKFZhbGlkYXRvclZhbHVlQ2hlY2tlci5wYXNzKGNvbnRyb2wsIGNvbmZpZykpIHtcclxuICAgICAgbGV0IHZhbGlkYXRvck5hbWVzID0gT2JqZWN0LmtleXMoY29uZmlnLnZhbGlkYXRpb24pO1xyXG4gICAgICBsZXQgZmFpbGVkOmJvb2xlYW4gPSBmYWxzZTtcclxuICAgICAgZm9yKHZhciB2YWxpZGF0b3JOYW1lIG9mIHZhbGlkYXRvck5hbWVzKXtcclxuICAgICAgICBmYWlsZWQgPSB0eXBlb2YgY29uZmlnLnZhbGlkYXRpb25bdmFsaWRhdG9yTmFtZV0gPT0gXCJib29sZWFuXCIgPyAgQVBQX1ZBTElEQVRPUlNbdmFsaWRhdG9yTmFtZV0oKShjb250cm9sKSA6ICBBUFBfVkFMSURBVE9SU1t2YWxpZGF0b3JOYW1lXShjb25maWcudmFsaWRhdGlvblt2YWxpZGF0b3JOYW1lXSkoY29udHJvbCk7XHJcbiAgICAgICAgaWYoIWZhaWxlZClcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghZmFpbGVkKVxyXG4gICAgICAgIHJldHVybiBPYmplY3RNYWtlci50b0pzb24oQW5ub3RhdGlvblR5cGVzLm5vdCwgY29uZmlnLCBbY29udHJvbC52YWx1ZV0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE9iamVjdE1ha2VyLm51bGwoKTtcclxuICB9XHJcbn1cclxuIl19